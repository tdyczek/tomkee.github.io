<!DOCTYPE html>
<html>
   
 <head>
        <meta charset="utf-8">
        <title>cannon.js + three.js physics shooter</title>
        <style>
            html, body {
                width: 100%;
                height: 100%;
            }

            body {
                background-color: #ffffff;
                margin: 0;
                overflow: hidden;
                font-family: arial;
            }

            #blocker {

                position: absolute;

                width: 100%;
                height: 100%;

                background-color: rgba(0,0,0,0.5);

            }

            #instructions {

                width: 100%;
                height: 100%;

                display: -webkit-box;
                display: -moz-box;
                display: box;

                -webkit-box-orient: horizontal;
                -moz-box-orient: horizontal;
                box-orient: horizontal;

                -webkit-box-pack: center;
                -moz-box-pack: center;
                box-pack: center;

                -webkit-box-align: center;
                -moz-box-align: center;
                box-align: center;

                color: #ffffff;
                text-align: center;

                cursor: pointer;

            }

        </style>
    </head>
    <body>
        <script src="js/Three.js"></script>
        <script src="js/cannon.js"></script>
        <script src="js/PointerLockControls.js"></script>
         <script src="js/water-material.js"></script>

        <div id="blocker">

            <div id="instructions">
                <span style="font-size:40px">Click to play</span>
                <br />
                (W,A,S,D = Move, SPACE = Jump, MOUSE = Look)
            </div>

        </div>

        <script>

            var sphereShape, sphereBody, world, physicsMaterial, walls=[], balls=[], ballMeshes=[], boxes=[], boxMeshes=[];

            var camera, scene, renderer, aMeshMirror;
            var geometry, material, mesh;
            var controls,time = Date.now();
            var levels = new Map();



            var halfExtents = new CANNON.Vec3(1,1,1);
            var boxShape = new CANNON.Box(halfExtents);
            var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);            
            var blocker = document.getElementById( 'blocker' );
            
            var instructions = document.getElementById( 'instructions' );

            var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

            if ( havePointerLock ) {

                var element = document.body;

                var pointerlockchange = function ( event ) {

                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

                        controls.enabled = true;

                        blocker.style.display = 'none';

                    } else {

                        controls.enabled = false;

                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';

                        instructions.style.display = '';

                    }

                }

                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                }

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {
                    instructions.style.display = 'none';

                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

                    if ( /Firefox/i.test( navigator.userAgent ) ) {

                        var fullscreenchange = function ( event ) {

                            if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

                                document.removeEventListener( 'fullscreenchange', fullscreenchange );
                                document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

                                element.requestPointerLock();
                            }

                        }

                        document.addEventListener( 'fullscreenchange', fullscreenchange, false );
                        document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

                        element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

                        element.requestFullscreen();

                    } else {

                        element.requestPointerLock();

                    }

                }, false );

            } else {

                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

            }

            initCannon();
            init();
            animate();

            function initCannon(){
                // Setup our world
                world = new CANNON.World();
                world.quatNormalizeSkip = 0;
                world.quatNormalizeFast = false;

                var solver = new CANNON.GSSolver();

                world.defaultContactMaterial.contactEquationStiffness = 1e9;
                world.defaultContactMaterial.contactEquationRelaxation = 1;

                solver.iterations = 7;
                solver.tolerance = 0.1;
                var split = true;
                if(split)
                    world.solver = new CANNON.SplitSolver(solver);
                else
                    world.solver = solver;

                world.gravity.set(0,-20,0);
                world.broadphase = new CANNON.NaiveBroadphase();

                // Create a slippery material (friction coefficient = 0.0)
                physicsMaterial = new CANNON.Material("someMaterial");
                physicsMaterial.friction = 0.1;
                physicsMaterial.restitution = 0.1;

                //world.addContactMaterial(physicsContactMaterial);

                // Create a sphere
                var mass = 5, radius = 1;
                var halfExtents1 = new CANNON.Vec3(1,1,1);
                sphereShape = new CANNON.Box(halfExtents1);
                sphereBody = new CANNON.Body({ mass: mass });
                sphereBody.addShape(sphereShape);
                sphereBody.position.set(0,5,0);
                sphereBody.linearDamping = 0.9;
                sphereBody.material = physicsMaterial;
                world.addBody(sphereBody);

                // Create a plane
                var groundShape = new CANNON.Plane();
                var groundBody = new CANNON.Body({ mass: 0 });
                groundBody.material = physicsMaterial;
                groundBody.addShape(groundShape);
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
                world.addBody(groundBody);
            }

            function init() {
                levels[0] = 1;
                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

                scene = new THREE.Scene();
                scene.fog = new THREE.Fog( 0x000000, 0, 500 );

              
                var light = new THREE.DirectionalLight( 0xffffff, 1.5 );
                light.position.set( 1, 1, 1 );
                scene.add( light );

                var light = new THREE.DirectionalLight( 0xffffff, 0.75 );
                light.position.set( -1, - 0.5, -1 );
                scene.add( light );


                controls = new PointerLockControls( camera , sphereBody );
                scene.add( controls.getObject() );
                
         

    
                material_for_boxes = new THREE.MeshLambertMaterial();
                material_for_boxes.map = THREE.ImageUtils.loadTexture("textures/metal-floor.jpg");

                renderer = new THREE.WebGLRenderer();
                renderer.shadowMapEnabled = true;
                renderer.shadowMapSoft = true;
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor( scene.fog.color, 1 );

                document.body.appendChild( renderer.domElement );

                window.addEventListener( 'resize', onWindowResize, false );
                // Add boxes
               
//
    var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(-120, 200, 120);
        scene.add(directionalLight);
                        var waterNormals = new THREE.ImageUtils.loadTexture('textures/waternormals.jpg');
        waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; 
        
        // Create the water effect
        this.ms_Water = new THREE.Water(renderer, camera, scene, {
            textureWidth: 10,
            textureHeight: 10,
            waterNormals: waterNormals,
            alpha:  1.0,
            sunDirection: directionalLight.position.normalize(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            betaVersion: 0,
            side: THREE.DoubleSide
        });
        aMeshMirror = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100), 
            this.ms_Water.material
        );
        aMeshMirror.add(this.ms_Water);
        aMeshMirror.rotation.x = - Math.PI * 0.5;
        aMeshMirror.position.y = -10;
        
        scene.add(aMeshMirror);
        this.ms_Water.render();

//


                for(var i=0; i<50; i++){
                    var x = Math.floor( Math.random() * 20 - 10 );
                    var y = Math.floor( Math.random() * 20 ) + 2;
                    var z = Math.floor( Math.random() * 20 - 10 );
                    var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    boxBody.material = physicsMaterial;
                    var boxMesh = new THREE.Mesh( boxGeometry, material_for_boxes );
                    world.addBody(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
                }
                for(var i=0; i<10; i++){
                    var x = Math.floor( Math.sin(Math.PI * 0.125 * i) * 15);
                    var y = Math.floor( i * 2 ) + 2;
                    var z = Math.floor( Math.cos(Math.PI * 0.125 * i) * 15);
                    var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    boxBody.material = physicsMaterial;
                    var boxMesh = new THREE.Mesh( boxGeometry, material_for_boxes );
                    world.addBody(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
                }

                var imagePrefix = "textures/dawnmountain-";
                var directions  = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
                var imageSuffix = ".png";
                var skyGeometry = new THREE.CubeGeometry( 100, 100, 100 );   
                
                var materialArray = [];
                for (var i = 0; i < 6; i++)
                    materialArray.push( new THREE.MeshBasicMaterial({
                        map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
                        side: THREE.BackSide
                    }));
                var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
                var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
                scene.add( skyBox );
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            var dt = 1/60;
            function animate() {
                this.ms_Water.material.uniforms.time.value += 1.0 / 60.0;
                requestAnimationFrame( animate );
                if(controls.enabled){
                    world.step(dt);

                }
                aMeshMirror.position.y += 0.02;
                controls.update( Date.now() - time );
                renderer.render( scene, camera );
                time = Date.now();
                
                if(!levels.has(Math.floor(sphereBody.position.y/20))){
                                    for(var i=0; i<40; i++){
                    var x = Math.floor( Math.random() * 20 - 10 );
                    var y = Math.floor( Math.random() * 20 ) + 2+ Math.floor(sphereBody.position.y/20) * 20;
                    var z = Math.floor( Math.random() * 20 - 10 );
                    var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    boxBody.material = physicsMaterial;
                    var boxMesh = new THREE.Mesh( boxGeometry, material_for_boxes );
                    world.addBody(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
                }
                for(var i=0; i<10; i++){
                    var x = Math.floor( Math.sin(Math.PI * 0.125 * i) * 15);
                    var y = Math.floor( i * 2 ) + 2 + Math.floor(sphereBody.position.y/20) * 20;
                    var z = Math.floor( Math.cos(Math.PI * 0.125 * i) * 15);
                    var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    boxBody.material = physicsMaterial;
                    var boxMesh = new THREE.Mesh( boxGeometry, material_for_boxes );
                    world.addBody(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
                }
                levels.set(Math.floor(sphereBody.position.y/20),1);
                    

                }
            }

        

           

        </script>
    </body>
</html>
